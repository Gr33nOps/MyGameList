const express = require('express');
const mysql = require('mysql2/promise');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const cors = require('cors');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// ==================== DATABASE SETUP ====================
const dbConfig = {
    host: process.env.DB_HOST || 'localhost',
    user: process.env.DB_USER || 'zain',
    password: process.env.DB_PASSWORD || '123',
    database: process.env.DB_NAME || 'MY_GAME_LIST',
    waitForConnections: true,
    connectionLimit: 10,
    queueLimit: 0
};

const pool = mysql.createPool(dbConfig);

// ==================== MIDDLEWARE ====================
app.use(cors());
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// JWT Secret
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';

// ==================== AUTH MIDDLEWARE ====================
const authenticateToken = async (req, res, next) => {
    const token = req.headers['authorization']?.split(' ')[1];
    if (!token) return res.status(401).json({ error: 'Access token required' });

    try {
        const decoded = jwt.verify(token, JWT_SECRET);
        const [users] = await pool.execute(
            'SELECT id, username, email, display_name FROM users WHERE id = ?',
            [decoded.userId]
        );
        if (users.length === 0) return res.status(401).json({ error: 'Invalid token' });
        req.user = users[0];
        next();
    } catch (error) {
        return res.status(403).json({ error: 'Invalid token' });
    }
};

// Optional auth - doesn't fail if no token
const optionalAuth = async (req, res, next) => {
    // ... similar logic but continues without user if token invalid
    next();
};

// ==================== HEALTH CHECK ====================
app.get('/api/health', async (req, res) => {
    try {
        await pool.execute('SELECT 1');
        res.json({ status: 'healthy', database: 'connected' });
    } catch (error) {
        res.status(500).json({ status: 'unhealthy', error: error.message });
    }
});

// ==================== AUTH ROUTES ====================

// Register new user
app.post('/api/auth/register', async (req, res) => {
    try {
        const { username, email, password, display_name } = req.body;
        
        // Validate required fields
        if (!username || !email || !password) {
            return res.status(400).json({ error: 'Username, email, and password required' });
        }

        // Check if user exists
        const [existing] = await pool.execute(
            'SELECT id FROM users WHERE username = ? OR email = ?',
            [username, email]
        );
        if (existing.length > 0) {
            return res.status(400).json({ error: 'User already exists' });
        }

        // Hash password and create user
        const hashedPassword = await bcrypt.hash(password, 12);
        const [result] = await pool.execute(
            'INSERT INTO users (username, email, password_hash, display_name, created_at, updated_at) VALUES (?, ?, ?, ?, NOW(), NOW())',
            [username, email, hashedPassword, display_name || username]
        );

        // Generate JWT token
        const token = jwt.sign({ userId: result.insertId }, JWT_SECRET, { expiresIn: '7d' });

        res.status(201).json({
            message: 'User created successfully',
            token,
            user: { id: result.insertId, username, email, display_name: display_name || username }
        });
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Login user
app.post('/api/auth/login', async (req, res) => {
    try {
        const { username, password } = req.body;
        
        // Find user by username or email
        const [users] = await pool.execute(
            'SELECT id, username, email, password_hash, display_name FROM users WHERE username = ? OR email = ?',
            [username, username]
        );
        if (users.length === 0) {
            return res.status(401).json({ error: 'Invalid credentials' });
        }

        // Verify password
        const user = users[0];
        const validPassword = await bcrypt.compare(password, user.password_hash);
        if (!validPassword) {
            return res.status(401).json({ error: 'Invalid credentials' });
        }

        // Generate token and return user data
        const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: '7d' });
        res.json({
            message: 'Login successful',
            token,
            user: { id: user.id, username: user.username, email: user.email, display_name: user.display_name }
        });
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Get current user profile
app.get('/api/auth/me', authenticateToken, (req, res) => {
    res.json({ user: req.user });
});

// ==================== GAMES ROUTES ====================

// Get all games with filtering and pagination
app.get('/api/games', optionalAuth, async (req, res) => {
    try {
        const { page = 1, limit = 20, search = '', genre = '', platform = '', ordering = '-rating' } = req.query;
        const offset = (parseInt(page) - 1) * parseInt(limit);
        
        // Build dynamic WHERE clause based on filters
        let whereConditions = [];
        let queryParams = [];

        if (search) {
            whereConditions.push('(g.name LIKE ? OR g.description LIKE ?)');
            queryParams.push(`%${search}%`, `%${search}%`);
        }
        if (genre) {
            whereConditions.push('g.id IN (SELECT gg.game_id FROM game_genres gg JOIN genres gen ON gg.genre_id = gen.id WHERE gen.slug = ?)');
            queryParams.push(genre);
        }
        // ... similar filters for platform, publisher, etc.

        const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(' AND ')}` : '';
        
        // Handle sorting
        let orderByClause = 'ORDER BY g.rating DESC';
        if (ordering === 'name') orderByClause = 'ORDER BY g.name ASC';
        // ... other ordering options

        // Get games with pagination
        const gamesQuery = `
            SELECT g.id, g.name, g.slug, g.description, g.rating, g.background_image
            FROM games g ${whereClause} ${orderByClause} 
            LIMIT ? OFFSET ?
        `;
        const [games] = await pool.execute(gamesQuery, [...queryParams, parseInt(limit), offset]);

        // Get related data (genres, platforms, etc.) for each game
        for (let game of games) {
            // Get genres
            const [genres] = await pool.execute(`
                SELECT gen.name, gen.slug FROM genres gen 
                JOIN game_genres gg ON gen.id = gg.genre_id 
                WHERE gg.game_id = ?
            `, [game.id]);
            game.genres = genres;
            
            // Add user status if authenticated
            if (req.user) {
                const [userStatus] = await pool.execute(
                    'SELECT status, score FROM user_game_lists WHERE user_id = ? AND game_id = ?',
                    [req.user.id, game.id]
                );
                game.user_status = userStatus[0] || null;
            }
        }

        res.json({ games, pagination: { page: parseInt(page), limit: parseInt(limit) } });
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Get single game by ID/slug
app.get('/api/games/:identifier', optionalAuth, async (req, res) => {
    try {
        const { identifier } = req.params;
        const isNumeric = /^\d+$/.test(identifier);
        
        // Query by ID or slug
        const query = isNumeric ? 
            'SELECT * FROM games WHERE id = ? OR rawg_id = ?' : 
            'SELECT * FROM games WHERE slug = ?';
        const params = isNumeric ? [identifier, identifier] : [identifier];
        
        const [games] = await pool.execute(query, params);
        if (games.length === 0) {
            return res.status(404).json({ error: 'Game not found' });
        }

        const game = games[0];

        // Get all related data (genres, platforms, screenshots, reviews, etc.)
        const [genres] = await pool.execute(
            'SELECT gen.name, gen.slug FROM genres gen JOIN game_genres gg ON gen.id = gg.genre_id WHERE gg.game_id = ?',
            [game.id]
        );
        // ... similar queries for platforms, developers, publishers, tags, stores, screenshots

        const [reviews] = await pool.execute(
            'SELECT ur.*, u.username FROM user_reviews ur JOIN users u ON ur.user_id = u.id WHERE ur.game_id = ? ORDER BY ur.created_at DESC LIMIT 10',
            [game.id]
        );

        res.json({ ...game, genres, reviews });
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
});

// ==================== USER GAME LISTS ROUTES ====================

// Add/Update game in user's list
app.post('/api/user/games/:gameId', authenticateToken, async (req, res) => {
    try {
        const { gameId } = req.params;
        const { status, score, progress_hours } = req.body;

        // Validate status
        const validStatuses = ['playing', 'completed', 'on_hold', 'dropped', 'plan_to_play'];
        if (status && !validStatuses.includes(status)) {
            return res.status(400).json({ error: 'Invalid status' });
        }

        // Check if game exists
        const [games] = await pool.execute(
            'SELECT id FROM games WHERE id = ? OR rawg_id = ?',
            [gameId, gameId]
        );
        if (games.length === 0) {
            return res.status(404).json({ error: 'Game not found' });
        }

        const actualGameId = games[0].id;

        // Upsert user game entry
        const [existing] = await pool.execute(
            'SELECT id FROM user_game_lists WHERE user_id = ? AND game_id = ?',
            [req.user.id, actualGameId]
        );

        if (existing.length > 0) {
            // Update existing
            await pool.execute(
                'UPDATE user_game_lists SET status = COALESCE(?, status), score = COALESCE(?, score), progress_hours = COALESCE(?, progress_hours), updated_at = NOW() WHERE user_id = ? AND game_id = ?',
                [status, score, progress_hours, req.user.id, actualGameId]
            );
            res.json({ message: 'Game updated successfully' });
        } else {
            // Create new
            await pool.execute(
                'INSERT INTO user_game_lists (user_id, game_id, status, score, progress_hours, created_at, updated_at) VALUES (?, ?, ?, ?, ?, NOW(), NOW())',
                [req.user.id, actualGameId, status || 'plan_to_play', score, progress_hours]
            );
            res.status(201).json({ message: 'Game added successfully' });
        }
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Get user's game list
app.get('/api/user/games', authenticateToken, async (req, res) => {
    try {
        const { status, page = 1, limit = 20, ordering = '-updated_at' } = req.query;
        const offset = (parseInt(page) - 1) * parseInt(limit);

        let whereCondition = 'WHERE ugl.user_id = ?';
        let queryParams = [req.user.id];

        if (status) {
            whereCondition += ' AND ugl.status = ?';
            queryParams.push(status);
        }

        const [games] = await pool.execute(`
            SELECT g.id, g.name, g.slug, g.background_image, g.rating,
                   ugl.status, ugl.score, ugl.progress_hours, ugl.updated_at
            FROM user_game_lists ugl
            JOIN games g ON ugl.game_id = g.id
            ${whereCondition}
            ORDER BY ugl.updated_at DESC
            LIMIT ? OFFSET ?
        `, [...queryParams, parseInt(limit), offset]);

        res.json({ games });
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Remove game from user's list
app.delete('/api/user/games/:gameId', authenticateToken, async (req, res) => {
    try {
        const { gameId } = req.params;
        const [result] = await pool.execute(
            'DELETE ugl FROM user_game_lists ugl JOIN games g ON ugl.game_id = g.id WHERE ugl.user_id = ? AND (g.id = ? OR g.rawg_id = ?)',
            [req.user.id, gameId, gameId]
        );

        if (result.affectedRows === 0) {
            return res.status(404).json({ error: 'Game not found in list' });
        }
        res.json({ message: 'Game removed successfully' });
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
});

// ==================== REVIEWS ROUTES ====================

// Create/Update review
app.post('/api/games/:gameId/reviews', authenticateToken, async (req, res) => {
    try {
        const { gameId } = req.params;
        const { title, content, score } = req.body;

        if (!content || score === undefined) {
            return res.status(400).json({ error: 'Content and score required' });
        }
        if (score < 0 || score > 10) {
            return res.status(400).json({ error: 'Score must be 0-10' });
        }

        // Check game exists and upsert review
        const [games] = await pool.execute('SELECT id FROM games WHERE id = ? OR rawg_id = ?', [gameId, gameId]);
        if (games.length === 0) return res.status(404).json({ error: 'Game not found' });

        const actualGameId = games[0].id;
        const [existing] = await pool.execute(
            'SELECT id FROM user_reviews WHERE user_id = ? AND game_id = ?',
            [req.user.id, actualGameId]
        );

        if (existing.length > 0) {
            await pool.execute(
                'UPDATE user_reviews SET title = ?, content = ?, score = ?, updated_at = NOW() WHERE user_id = ? AND game_id = ?',
                [title, content, score, req.user.id, actualGameId]
            );
            res.json({ message: 'Review updated' });
        } else {
            await pool.execute(
                'INSERT INTO user_reviews (user_id, game_id, title, content, score, created_at, updated_at) VALUES (?, ?, ?, ?, ?, NOW(), NOW())',
                [req.user.id, actualGameId, title, content, score]
            );
            res.status(201).json({ message: 'Review created' });
        }
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Get reviews for a game
app.get('/api/games/:gameId/reviews', async (req, res) => {
    try {
        const { gameId } = req.params;
        const [reviews] = await pool.execute(`
            SELECT ur.id, ur.title, ur.content, ur.score, ur.created_at,
                   u.username, u.display_name
            FROM user_reviews ur
            JOIN users u ON ur.user_id = u.id
            JOIN games g ON ur.game_id = g.id
            WHERE g.id = ? OR g.rawg_id = ?
            ORDER BY ur.created_at DESC
        `, [gameId, gameId]);

        res.json({ reviews });
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
});

// ==================== METADATA ROUTES ====================

// Get all genres/platforms/publishers/developers/tags/stores
app.get('/api/genres', async (req, res) => {
    try {
        const [genres] = await pool.execute(
            'SELECT g.*, COUNT(gg.game_id) as games_count FROM genres g LEFT JOIN game_genres gg ON g.id = gg.genre_id GROUP BY g.id ORDER BY games_count DESC'
        );
        res.json({ genres });
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Similar endpoints for platforms, publishers, developers, tags, stores...

// ==================== SOCIAL FEATURES ====================

// Follow/Unfollow user
app.post('/api/users/:userId/follow', authenticateToken, async (req, res) => {
    // Follow user logic...
});

app.delete('/api/users/:userId/follow', authenticateToken, async (req, res) => {
    // Unfollow user logic...
});

// Get user profile
app.get('/api/users/:userId', optionalAuth, async (req, res) => {
    // Get user profile with stats, recent activity, etc.
});

// ==================== CUSTOM LISTS ====================

// CRUD operations for user custom lists
app.post('/api/user/lists', authenticateToken, async (req, res) => {
    // Create custom list...
});

app.get('/api/user/lists', authenticateToken, async (req, res) => {
    // Get user's custom lists...
});

// ==================== STATISTICS ====================

app.get('/api/stats', async (req, res) => {
    try {
        // Get platform statistics (total games, users, reviews, etc.)
        const [totalGames] = await pool.execute('SELECT COUNT(*) as count FROM games');
        const [totalUsers] = await pool.execute('SELECT COUNT(*) as count FROM users');
        
        res.json({
            stats: {
                total_games: totalGames[0].count,
                total_users: totalUsers[0].count
            }
        });
    } catch (error) {
        res.status(500).json({ error: 'Internal server error' });
    }
});

// ==================== ERROR HANDLING ====================

// 404 handler
app.use('*', (req, res) => {
    res.status(404).json({ error: 'Route not found' });
});

// Global error handler
app.use((error, req, res, next) => {
    console.error('Global error:', error);
    res.status(500).json({ error: 'Internal server error' });
});

// ==================== SERVER START ====================

app.listen(PORT, () => {
    console.log(`🚀 MyGameList server running on port ${PORT}`);
    console.log(`📊 Health check: http://localhost:${PORT}/api/health`);
});

// Graceful shutdown
process.on('SIGTERM', async () => {
    console.log('Shutting down gracefully...');
    await pool.end();
    process.exit(0);
});

module.exports = app;